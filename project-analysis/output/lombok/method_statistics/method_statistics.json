{
    "top_methods": [
        {
            "method": "Case.invoke()",
            "count": 56,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "Case.Case(JCExpression pat, List<JCStatement> stats)",
                "Case.DefaultCaseLabel()",
                "Case.ConstantCaseLabel(JCExpression expr)",
                "Case.Synchronized(JCExpression lock, JCBlock body)",
                "Case.Try(JCBlock body, List<JCCatch> catchers, JCBlock finalizer)",
                "Case.Try(List<JCTree> resources, JCBlock body, List<JCCatch> catchers, JCBlock finalizer)",
                "Case.Catch(JCVariableDecl param, JCBlock body)",
                "Case.Conditional(JCExpression cond, JCExpression thenpart, JCExpression elsepart)",
                "Case.If(JCExpression cond, JCStatement thenpart, JCStatement elsepart)",
                "Case.Exec(JCExpression expr)",
                "Case.Break(Name label)",
                "Case.Continue(Name label)",
                "Case.Return(JCExpression expr)",
                "Case.Throw(JCExpression expr)",
                "Case.Assert(JCExpression cond, JCExpression detail)",
                "Case.Apply(List<JCExpression> typeargs, JCExpression fn, List<JCExpression> args)",
                "Case.NewClass(JCExpression encl, List<JCExpression> typeargs, JCExpression clazz, List<JCExpression> args, JCClassDecl def)",
                "Case.NewArray(JCExpression elemtype, List<JCExpression> dims, List<JCExpression> elems)",
                "Case.Parens(JCExpression expr)",
                "Case.Assign(JCExpression lhs, JCExpression rhs)",
                "Case.Assignop(TreeTag opcode, JCTree lhs, JCTree rhs)",
                "Case.Unary(TreeTag opcode, JCExpression arg)",
                "Case.Binary(TreeTag opcode, JCExpression lhs, JCExpression rhs)",
                "Case.TypeCast(JCTree expr, JCExpression type)",
                "Case.TypeTest(JCExpression expr, JCTree clazz)",
                "Case.Indexed(JCExpression indexed, JCExpression index)",
                "Case.Select(JCExpression selected, Name selector)",
                "Case.Ident(Name idname)",
                "Case.Literal(TypeTag tag, Object value)",
                "Case.TypeIdent(TypeTag typetag)",
                "Case.TypeArray(JCExpression elemtype)",
                "Case.TypeApply(JCExpression clazz, List<JCExpression> arguments)",
                "Case.TypeParameter(Name name, List<JCExpression> bounds)",
                "Case.TypeParameter(Name name, List<JCExpression> bounds, List<JCAnnotation> annos)",
                "Case.Wildcard(TypeBoundKind kind, JCTree type)",
                "Case.TypeBoundKind(BoundKind kind)",
                "Case.Annotation(JCTree annotationType, List<JCExpression> args)",
                "Case.TypeAnnotation(JCTree annotationType, List<JCExpression> args)",
                "Case.Modifiers(long flags, List<JCAnnotation> annotations)",
                "Case.Modifiers(long flags)",
                "Case.Erroneous()",
                "Case.Erroneous(List<? extends JCTree> errs)",
                "Case.LetExpr(List<JCVariableDecl> defs, JCTree expr)",
                "Case.AnonymousClassDef(JCModifiers mods, List<JCTree> defs)",
                "Case.LetExpr(JCVariableDecl def, JCTree expr)",
                "Case.Ident(JCVariableDecl param)",
                "Case.Idents(List<JCVariableDecl> params)",
                "Case.App(JCExpression meth, List<JCExpression> args)",
                "Case.App(JCExpression meth)",
                "Case.Annotations(List<Attribute.Compound> attributes)",
                "Case.Literal(Object value)",
                "Case.Annotation(Attribute a)",
                "Case.TypeAnnotation(Attribute a)",
                "Case.AnnotatedType(List<JCAnnotation> annotations, JCExpression underlyingType)",
                "Case.Call(JCExpression apply)",
                "Case.Type(Type type)"
            ]
        },
        {
            "method": "ParentBuilder.self(final int self)",
            "count": 48,
            "source_code": "\t\t\tpublic B self(final int self) {\n\t\t\t\tthis.self = self;\n\t\t\t\treturn self();\n\t\t\t}",
            "callers": [
                "ParentBuilder.field1(final int field1)",
                "ParentBuilder.self()",
                "ParentBuilder.x(final int x)",
                "ParentBuilder.y(final int y)",
                "ParentBuilder.z(final int z)",
                "ParentBuilder.name(final String name)",
                "ParentBuilder.names(final java.util.@org.checkerframework.checker.nullness.qual.NonNull Collection<? extends String> names)",
                "ParentBuilder.clearNames()",
                "ParentBuilder.parentField(final int parentField)",
                "ParentBuilder.item(final String item)",
                "ParentBuilder.items(final java.util.Collection<? extends String> items)",
                "ParentBuilder.clearItems()",
                "ParentBuilder.obtainViaField(final int obtainViaField)",
                "ParentBuilder.obtainViaMethod(final int obtainViaMethod)",
                "ParentBuilder.obtainViaStaticMethod(final String obtainViaStaticMethod)",
                "ParentBuilder.resetToDefault()",
                "ParentBuilder.field1(int field1)",
                "ParentBuilder.setField1(int field1)",
                "ParentBuilder.card(final T card)",
                "ParentBuilder.cards(final java.lang.Iterable<? extends T> cards)",
                "ParentBuilder.clearCards()",
                "ParentBuilder.frog(final Number frog)",
                "ParentBuilder.frogs(final java.lang.Iterable<? extends Number> frogs)",
                "ParentBuilder.clearFrogs()",
                "ParentBuilder.rawSet(final java.lang.Object rawSet)",
                "ParentBuilder.rawSet(final java.lang.Iterable<?> rawSet)",
                "ParentBuilder.clearRawSet()",
                "ParentBuilder.pass(final String pass)",
                "ParentBuilder.passes(final java.lang.Iterable<? extends String> passes)",
                "ParentBuilder.clearPasses()",
                "ParentBuilder.user(final Number rowKey, final Number columnKey, final String value)",
                "ParentBuilder.users(final com.google.common.collect.Table<? extends Number, ? extends Number, ? extends String> users)",
                "ParentBuilder.clearUsers()",
                "ParentBuilder.field1(final A field1)",
                "ParentBuilder.millis(final long millis)",
                "ParentBuilder.numberField(final N numberField)",
                "ParentBuilder.foo(final String foo)",
                "ParentBuilder.str(final String str)",
                "ParentBuilder.item(final Integer itemKey, final String itemValue)",
                "ParentBuilder.items(final java.util.Map<? extends Integer, ? extends String> items)",
                "ParentBuilder.nonNullParentField(@lombok.NonNull final String nonNullParentField)",
                "ParentBuilder.self(final int self)",
                "ParentBuilder.withField1(final int field1)",
                "ParentBuilder.withObtainViaField(final int obtainViaField)",
                "ParentBuilder.withObtainViaMethod(final int obtainViaMethod)",
                "ParentBuilder.withObtainViaStaticMethod(final String obtainViaStaticMethod)",
                "ParentBuilder.withItem(final String item)",
                "ParentBuilder.withItems(final java.util.Collection<? extends String> items)"
            ]
        },
        {
            "method": "List.nil()",
            "count": 37,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "BuilderFieldData.generateBuilderMethod(BuilderJob job)",
                "BuilderFieldData.generateToBuilderMethod(BuilderJob job, List<JCTypeParameter> typeParameters, String prefix)",
                "BuilderFieldData.generateReceiver(BuilderJob job)",
                "HandleAllArgsConstructor.createStaticConstructor(String name, AccessLevel level, JavacNode typeNode, List<JavacNode> fields, JavacNode source)",
                "does.createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, JavacNode source, List<JCAnnotation> onParam)",
                "does.createCanEqual(JavacNode typeNode, JavacNode source, List<JCAnnotation> onParam)",
                "HandleGetter.createGetter(long access, JavacNode field, JavacTreeMaker treeMaker, JavacNode source, boolean lazy, List<JCAnnotation> onMethod)",
                "HandleGetter.findDelegatesAndRemoveFromField(JavacNode field)",
                "HandleNonNull.addCompactConstructorIfNeeded(JavacNode typeNode, JavacNode source)",
                "HandleNonNull.addNullCheckIfNeeded(JCMethodDecl method, JavacNode paramNode, JavacNode source)",
                "or.createSetterWithRecv(long access, boolean deprecate, JavacNode field, JavacTreeMaker treeMaker, String setterName, Name paramName, Name booleanFieldToSet, JCExpression methodType, JCStatement returnStatement, JavacNode source, List<JCAnnotation> onMethod, List<JCAnnotation> onParam, JCVariableDecl recv)",
                "SuperBuilderJob.generateBuilderMethod(SuperBuilderJob job)",
                "SuperBuilderJob.generateFillValuesMethod(SuperBuilderJob job, boolean inherited, String builderGenericName, String classGenericName)",
                "SuperBuilderJob.handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast, JavacNode annotationNode)",
                "SuperBuilderJob.generateStaticFillValuesMethod(SuperBuilderJob job, String setterPrefix)",
                "SuperBuilderJob.generateAbstractSelfMethod(SuperBuilderJob job, boolean override, String builderGenericName)",
                "SuperBuilderJob.generateSelfMethod(SuperBuilderJob job)",
                "SuperBuilderJob.generateAbstractBuildMethod(SuperBuilderJob job, boolean override, String classGenericName)",
                "SuperBuilderJob.getSingularData(JavacNode node, String setterPrefix)",
                "HandleUtilityClass.createThrowStatement(JavacNode typeNode, JavacTreeMaker maker)",
                "HandleWith.createWith(long access, JavacNode field, JavacTreeMaker maker, JavacNode source, List<JCAnnotation> onMethod, List<JCAnnotation> onParam, boolean makeAbstract)",
                "HandleWithBy.createWithBy(long access, JavacNode field, JavacTreeMaker maker, JavacNode source, List<JCAnnotation> onMethod, boolean makeAbstract)",
                "CantMakeDelegates.createDelegateMethod(MethodSig sig, JavacNode annotation, Name delegateName, DelegateReceiver delegateReceiver)",
                "JCAnnotatedTypeReflect.getAnnotations(JCTree obj)",
                "EnterReflect.findAnnotationsInList(JavacNode node, java.util.List<String> annotationsToFind)",
                "EnterReflect.sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(JavacNode typeNode, JavacNode errorNode)",
                "JavacSingularizer.generateMethods(final BuilderJob job, SingularData data, boolean deprecate)",
                "JavacGuavaSingularizer.createConstructBuilderVarIfNeeded(JavacTreeMaker maker, SingularData data, JavacNode builderType, JavacNode source)",
                "JavacJavaUtilListSetSingularizer.generateClearStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType)",
                "JavacJavaUtilListSingularizer.createListCopy(JavacTreeMaker maker, SingularData data, JavacNode builderType, JavacNode source, String builderVariable)",
                "JavacJavaUtilMapSingularizer.generateClearStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType)",
                "JavacJavaUtilMapSingularizer.generatePluralMethodStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, JavacNode source)",
                "JavacJavaUtilSingularizer.createJavaUtilSetMapInitialCapacitySwitchStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, boolean mapMode, String emptyCollectionMethod, String singletonCollectionMethod, String targetType, JavacNode source, String builderVariable)",
                "JavacJavaUtilSingularizer.createConstructBuilderVarIfNeeded(JavacTreeMaker maker, SingularData data, JavacNode builderType, boolean mapMode, JavacNode source)",
                "JavacJavaUtilSingularizer.createJavaUtilSimpleCreationAndFillStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, boolean mapMode, boolean defineVar, boolean addInitialCapacityArg, boolean nullGuard, String targetType, JavacNode source, String builderVariable)",
                "InvalidFormatOptionException.delombok()",
                "ValidatePositionProcessor.isLombokGenerated(JCTree tree)"
            ]
        },
        {
            "method": "Collections.emptyList()",
            "count": 35,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "ClassFileMetaData.getInterfaces()",
                "AnnotationValueDecodeFail.getProbableFQTypes(String annotationMethodName)",
                "LombokApp.getAppName()",
                "LombokNode.upFromAnnotationToFields()",
                "PostCompiler.init(DiagnosticsReceiver diagnostics)",
                "TypeLibrary.toQualifieds(String typeReference)",
                "BubblingConfigurationResolver.resolve(ConfigurationKey<T> key)",
                "GetterMethod.unboxAndRemoveAnnotationParameter(Annotation annotation, String annotationName, String errorName, EclipseNode errorNode)",
                "HandleWith.generateWithForField(EclipseNode fieldNode, EclipseNode sourceNode, AccessLevel level)",
                "HandleWithBy.generateWithByForField(EclipseNode fieldNode, EclipseNode sourceNode, AccessLevel level)",
                "EclipseJavaUtilSingularizer.createConstructBuilderVarIfNeeded(SingularData data, EclipseNode builderType, boolean mapMode)",
                "JavacAST.getResourcesForTryNode(JCTry tryNode)",
                "NoErrorsTest.fieldNameConstantsInAnnotation()",
                "NoErrorsTest.builderJavadoc()",
                "NoErrorsTest.synchronizedUsage()",
                "BuilderDefaultsWarningsBuilder.build()",
                "BuilderSingularListsBuilder.build()",
                "BuilderSingularNoAutoBuilder.build()",
                "BuilderSingularNoAutoWithSetterPrefixBuilder.build()",
                "BuilderSingularNullBehavior1Builder.build()",
                "BuilderSingularNullBehavior2Builder.build()",
                "BuilderSingularOnRecordBuilder.build()",
                "BuilderSingularToBuilderWithNullBuilder.build()",
                "BuilderSingularToBuilderWithNullWithSetterPrefixBuilder.build()",
                "BuilderSingularWildcardListsWithToBuilderBuilder.build()",
                "BuilderSingularWithPrefixesBuilder.build()",
                "BuilderSingularWithPrefixesWithSetterPrefixBuilder.build()",
                "BuilderWithDeprecatedBuilder.build()",
                "BuilderWithDeprecatedAnnOnlyBuilder.build()",
                "BuilderWithJavaBeansSpecCapitalizationBuilder.build()",
                "BuilderWithToBuilderBuilder.build()",
                "CheckerFrameworkBuilderBuilder.build(CheckerFrameworkBuilder.@org.checkerframework.checker.calledmethods.qual.CalledMethods({\"y\", \"z\"})",
                "JacksonBuilderSingularBuilder.build()",
                "JacksonizedOnRecordBuilder.build()",
                "ValWeirdTypes.testGenericsInference()"
            ]
        },
        {
            "method": "List.of()",
            "count": 30,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "HandleAllArgsConstructor.createStaticConstructor(String name, AccessLevel level, JavacNode typeNode, List<JavacNode> fields, JavacNode source)",
                "does.createHashCode(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, boolean cacheHashCode, FieldAccess fieldAccess, JavacNode source)",
                "does.createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, JavacNode source, List<JCAnnotation> onParam)",
                "does.createCanEqual(JavacNode typeNode, JavacNode source, List<JCAnnotation> onParam)",
                "or.createSetterWithRecv(long access, boolean deprecate, JavacNode field, JavacTreeMaker treeMaker, String setterName, Name paramName, Name booleanFieldToSet, JCExpression methodType, JCStatement returnStatement, JavacNode source, List<JCAnnotation> onMethod, List<JCAnnotation> onParam, JCVariableDecl recv)",
                "HandleSneakyThrows.handleMethod(JavacNode annotation, JCMethodDecl method, Collection<String> exceptions)",
                "HandleStandardException.generateNoArgsConstructor(JavacNode typeNode, AccessLevel level, JavacNode source)",
                "HandleStandardException.generateMsgOnlyConstructor(JavacNode typeNode, AccessLevel level, JavacNode source)",
                "HandleStandardException.generateCauseOnlyConstructor(JavacNode typeNode, AccessLevel level, JavacNode source)",
                "HandleStandardException.generateFullConstructor(JavacNode typeNode, AccessLevel level, JavacNode source)",
                "SuperBuilderJob.generateFillValuesMethod(SuperBuilderJob job, boolean inherited, String builderGenericName, String classGenericName)",
                "SuperBuilderJob.handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast, JavacNode annotationNode)",
                "SuperBuilderJob.generateAbstractBuildMethod(SuperBuilderJob job, boolean override, String classGenericName)",
                "SuperBuilderJob.generateBuildMethod(SuperBuilderJob job, List<JCExpression> thrownExceptions)",
                "HandleUtilityClass.createThrowStatement(JavacNode typeNode, JavacTreeMaker maker)",
                "HandleVal.endVisitLocal(JavacNode localNode, JCVariableDecl local)",
                "HandleWith.createWith(long access, JavacNode field, JavacTreeMaker maker, JavacNode source, List<JCAnnotation> onMethod, List<JCAnnotation> onParam, boolean makeAbstract)",
                "HandleWithBy.createWithBy(long access, JavacNode field, JavacTreeMaker maker, JavacNode source, List<JCAnnotation> onMethod, boolean makeAbstract)",
                "EnterReflect.addAnnotation(JCModifiers mods, JavacNode node, JavacNode source, String annotationTypeFqn, JCExpression arg)",
                "EnterReflect.findAnnotationsInList(JavacNode node, java.util.List<String> annotationsToFind)",
                "EnterReflect.applyAnnotationToMethodDecl(JavacNode typeNode, JCMethodDecl mth, String annType, boolean typeUse)",
                "EnterReflect.applyAnnotationToVarDecl(JavacNode typeNode, JCVariableDecl arg, String annType, boolean typeUse)",
                "JavacSingularizer.makeMods(JavacTreeMaker maker, JavacNode node, boolean deprecate, AccessLevel access, List<JCAnnotation> methodAnnotations)",
                "JavacSingularizer.generateMethods(final BuilderJob job, SingularData data, boolean deprecate)",
                "JavacJavaUtilListSetSingularizer.generateSingularMethodParameters(JavacTreeMaker maker, SingularData data, JavacNode builderType, JavacNode source)",
                "JavacJavaUtilListSingularizer.createListCopy(JavacTreeMaker maker, SingularData data, JavacNode builderType, JavacNode source, String builderVariable)",
                "JavacJavaUtilMapSingularizer.generateSingularMethodParameters(JavacTreeMaker maker, SingularData data, JavacNode builderType, JavacNode source)",
                "JavacJavaUtilSingularizer.createJavaUtilSetMapInitialCapacitySwitchStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, boolean mapMode, String emptyCollectionMethod, String singletonCollectionMethod, String targetType, JavacNode source, String builderVariable)",
                "JavacJavaUtilSingularizer.createJavaUtilSimpleCreationAndFillStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, boolean mapMode, boolean defineVar, boolean addInitialCapacityArg, boolean nullGuard, String targetType, JavacNode source, String builderVariable)",
                "Case.Case(JCExpression pat, List<JCStatement> stats)"
            ]
        },
        {
            "method": "Arrays.equals()",
            "count": 28,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "EqualsAndHashCode.equals(final java.lang.Object o)",
                "EclipseReflectiveMembers.findInnerClass(EclipseNode parent, String name)",
                "GetterMethod.fieldExists(String fieldName, EclipseNode node)",
                "GetterMethod.addAnnotation(ASTNode source, Annotation[] originalAnnotationArray, char[][] annotationTypeFqn, ASTNode... args)",
                "GetterMethod.unboxAndRemoveAnnotationParameter(Annotation annotation, String annotationName, String errorName, EclipseNode errorNode)",
                "EclipseSingularizer.getSupportedTypes()",
                "EclipseSingularizer.listMethodsToBeGenerated(SingularData data, EclipseNode builderType)",
                "BuilderFieldData.returnTypeToBuilderClassName(EclipseNode annotationNode, MethodDeclaration md, TypeParameter[] typeParams)",
                "BuilderFieldData.generateBuildMethod(BuilderJob job, char[] staticName, TypeReference returnType, TypeReference[] thrownExceptions, boolean addCleaning)",
                "BuilderFieldData.generateBuilderFields(BuilderJob job)",
                "BuilderFieldData.makePrefixedSetterMethodForBuilder(BuilderJob job, BuilderFieldData bfd, boolean deprecate, String prefix)",
                "HandleCleanup.doAssignmentCheck0(EclipseNode node, Statement statement, char[] varName)",
                "HandleAllArgsConstructor.getDefaultExpr(TypeReference type, int s, int e)",
                "does.createHashCode(EclipseNode type, Collection<Included<EclipseNode, EqualsAndHashCode.Include>> members, boolean callSuper, boolean cacheHashCode, ASTNode source, FieldAccess fieldAccess)",
                "does.createEquals(EclipseNode type, Collection<Included<EclipseNode, EqualsAndHashCode.Include>> members, boolean callSuper, ASTNode source, FieldAccess fieldAccess, boolean needsCanEqual, List<Annotation> onParam)",
                "HandleLockedUtil.createLockField(String name, EclipseNode annotationNode, char[][] lockTypeClass, char[][] lockImplClass, AtomicBoolean isStatic, boolean reportErrors)",
                "HandleNonNull.addCompactConstructorIfNeeded(EclipseNode typeNode, EclipseNode annotationNode)",
                "HandleNonNull.addNullCheckIfNeeded(AbstractMethodDeclaration declaration, AbstractVariableDeclaration param, EclipseNode annotationNode)",
                "HandleNonNull.returnVarNameIfNullCheck(Statement stat)",
                "or.createWithBy(TypeDeclaration parent, EclipseNode fieldNode, String name, int modifier, EclipseNode sourceNode, List<Annotation> onMethod, boolean makeAbstract)",
                "SuperBuilderJob.generateBuilderFields(BuilderJob job)",
                "SuperBuilderJob.generateSimpleSetterMethodForBuilder(BuilderJob job, boolean deprecate, EclipseNode fieldNode, char[] paramName, char[] nameOfSetFlag, TypeReference returnType, Statement returnStatement, Annotation[] annosOnParam, EclipseNode originalFieldNode, String setterPrefix)",
                "SuperBuilderJob.findInnerClass(EclipseNode parent, String name)",
                "HandleSynchronized.createLockField(AnnotationValues<Synchronized> annotation, EclipseNode annotationNode, boolean[] isStatic, boolean reportErrors)",
                "DelegateRecursion.failIfContainsAnnotation(TypeBinding parent, Binding[] bindings)",
                "PostponedError.resolveType(TypeBinding resolvedType, MessageSend methodCall, BlockScope scope)",
                "EqualsAndHashCodeAnnotated.equals(final java.lang.Object o)",
                "EqualsAndHashCodeWithOnParam.equals(@Nullable final java.lang.Object o)"
            ]
        },
        {
            "method": "Permit.getField()",
            "count": 28,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "ProcessorDescriptor.tryGetDelegateField(Class<?> delegateClass, Object instance)",
                "ProcessorDescriptor.tryGetProcessingEnvField(Class<?> delegateClass, Object instance)",
                "ProcessorDescriptor.tryGetProxyDelegateToField(Class<?> delegateClass, Object instance)",
                "EclipseReflectiveMembers.getField(Class<?> c, String fName)",
                "CompilerMessageSuppressor.getDeclaredField(Class<?> c, String fieldName)",
                "ErrorLog.create(Messager messager, Context context)",
                "EnvFinder.getMemberEnterDotEnv()",
                "LombokProcessor.getFieldAccessor(String typeName, String fieldName)",
                "LombokProcessor.placePostCompileAndDontMakeForceRoundDummiesHook()",
                "LombokProcessor.replaceFileManagerJdk9(Context context, JavaFileManager newFiler)",
                "LombokProcessor.forceMultipleRoundsInNetBeansEditor()",
                "LombokProcessor.disablePartialReparseInNetBeansEditor(Context context)",
                "LombokProcessor.stopJavacProcessingEnvironmentFromClosingOurClassloader()",
                "LombokProcessor.tryGetDelegateField(Class<?> delegateClass, Object instance)",
                "LombokProcessor.tryGetProcessingEnvField(Class<?> delegateClass, Object instance)",
                "LombokProcessor.tryGetFilerField(Class<?> delegateClass, Object instance)",
                "LombokProcessor.tryGetProxyDelegateToField(Class<?> delegateClass, Object instance)",
                "Processor.listOptions(StringBuilder message, ProcessingEnvironment procEnv)",
                "Processor.findServices(StringBuilder message, Filer filer)",
                "InvalidFormatOptionException.getModuleField()",
                "UncheckedIOException.readObject(JCTree tree, String fieldName, T defaultValue)",
                "Reflection.getField(Class<?> clazz, String name)",
                "FieldAugment.findField(Class<?> type, Class<?> wantedType, String name)",
                "CommentCatcher.registerCommentsCollectingScannerFactory(Context context, boolean findTextBlocks)",
                "JavadocOps_8.getFieldIfExists(Class<?> c, String fieldName)",
                "SchroedingerType.getFieldCached(ConcurrentMap<String, Object> cache, String className, String fieldName)",
                "SchroedingerType.getFieldCached(ConcurrentMap<Class<?>, Field> cache, Object ref, String fieldName)",
                "CommentCollectingParserFactory.setInCompiler(JavaCompiler compiler, Context context)"
            ]
        },
        {
            "method": "GetterMethod.get()",
            "count": 28,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "GetterMethod.findGetter(EclipseNode field)",
                "GetterMethod.getFieldType(EclipseNode field, FieldAccess fieldAccess)",
                "GetterMethod.createFieldAccessor(EclipseNode field, FieldAccess fieldAccess, ASTNode source)",
                "GetterMethod.createMethodAccessor(EclipseNode method, ASTNode source)",
                "GetterMethod.createMethodAccessor(EclipseNode method, ASTNode source, char[] receiver)",
                "GetterMethod.shouldMakeFinal(EclipseNode field, AnnotationValues<Accessors> accessors)",
                "GetterMethod.shouldReturnThis(EclipseNode field, AnnotationValues<Accessors> accessors)",
                "GetterMethod.removePrefixFromField(EclipseNode field)",
                "GetterMethod.upToTypeNode(EclipseNode node)",
                "GetterMethod.fieldExists(String fieldName, EclipseNode node)",
                "GetterMethod.methodExists(String methodName, EclipseNode node, boolean caseSensitive, int params)",
                "GetterMethod.constructorExists(EclipseNode node)",
                "GetterMethod.injectField(EclipseNode type, FieldDeclaration field)",
                "GetterMethod.injectMethod(EclipseNode type, AbstractMethodDeclaration method)",
                "GetterMethod.injectType(final EclipseNode typeNode, final TypeDeclaration type)",
                "GetterMethod.generateNullCheck(TypeReference type, char[] variable, EclipseNode sourceNode, String customMessage)",
                "GetterMethod.createListOfNonExistentFields(List<String> list, EclipseNode type, boolean excludeStandard, boolean excludeTransient)",
                "GetterMethod.isDirectDescendantOfObject(EclipseNode typeNode)",
                "GetterMethod.isRecord(EclipseNode typeNode)",
                "GetterMethod.isTypeAndDoesNotHaveFlags(EclipseNode typeNode, long flags)",
                "GetterMethod.getDocComment(EclipseNode eclipseNode)",
                "GetterMethod.setDocComment(CompilationUnitDeclaration cud, EclipseNode eclipseNode, String doc)",
                "GetterMethod.hasParsedBody(EclipseNode method)",
                "GetterMethod.findGetter(JavacNode field)",
                "GetterMethod.getFieldType(JavacNode field, FieldAccess fieldAccess)",
                "GetterMethod.createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess, JCExpression receiver)",
                "GetterMethod.createMethodAccessor(JavacTreeMaker maker, JavacNode method, JCExpression receiver)",
                "GetterMethod.injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated, boolean specialEnumHandling)"
            ]
        },
        {
            "method": "EclipsePatcher.addScriptIfWitness()",
            "count": 28,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "EclipsePatcher.patchExtractInterfaceAndPullUp(ScriptManager sm)",
                "EclipsePatcher.patchInline(ScriptManager sm)",
                "EclipsePatcher.patchAboutDialog(ScriptManager sm)",
                "EclipsePatcher.patchSyntaxAndOccurrencesHighlighting(ScriptManager sm)",
                "EclipsePatcher.patchListRewriteHandleGeneratedMethods(ScriptManager sm)",
                "EclipsePatcher.patchSortMembersOperation(ScriptManager sm)",
                "EclipsePatcher.patchDomAstReparseIssues(ScriptManager sm)",
                "EclipsePatcher.patchPostCompileHookEclipse(ScriptManager sm)",
                "EclipsePatcher.patchHideGeneratedNodes(ScriptManager sm)",
                "EclipsePatcher.patchFormatters(ScriptManager sm)",
                "EclipsePatcher.patchRefactorScripts(ScriptManager sm)",
                "EclipsePatcher.patchIdentifierEndReparse(ScriptManager sm)",
                "EclipsePatcher.patchRetrieveEllipsisStartPosition(ScriptManager sm)",
                "EclipsePatcher.patchRetrieveStartBlockPosition(ScriptManager sm)",
                "EclipsePatcher.patchRetrieveRightBraceOrSemiColonPosition(ScriptManager sm)",
                "EclipsePatcher.patchRetrieveProperRightBracketPosition(ScriptManager sm)",
                "EclipsePatcher.patchSetGeneratedFlag(ScriptManager sm)",
                "EclipsePatcher.addPatchesForDelegate(ScriptManager sm)",
                "EclipsePatcher.addPatchesForValEclipse(ScriptManager sm)",
                "EclipsePatcher.patchFixSourceTypeConverter(ScriptManager sm)",
                "EclipsePatcher.patchEclipseDebugPatches(ScriptManager sm)",
                "EclipsePatcher.patchExtensionMethod(ScriptManager sm)",
                "EclipsePatcher.patchJavadoc(ScriptManager sm)",
                "EclipsePatcher.patchASTConverterLiterals(ScriptManager sm)",
                "EclipsePatcher.patchASTNodeSearchUtil(ScriptManager sm)",
                "EclipsePatcher.patchFieldInitializer(ScriptManager sm)",
                "EclipsePatcher.patchCrossModuleClassLoading(ScriptManager sm)",
                "EclipsePatcher.patchForTests(ScriptManager sm)"
            ]
        },
        {
            "method": "Class.forName()",
            "count": 27,
            "source_code": "工具类、常量类或接口方法",
            "callers": [
                "AstModificationNotifier.isLombokInvoked()",
                "AgentLaunchable.runAgents(String agentArgs, Instrumentation instrumentation, boolean injected, Class<?> launchingContext)",
                "AnnotationProcessor.disableJava9SillyWarning()",
                "AnnotationValueDecodeFail.guessToType(Object guess, Class<?> expected, AnnotationValue v, int pos)",
                "AnnotationValueDecodeFail.toFQ(String typeName)",
                "LoaderLoader.loadAllConfigurationKeys()",
                "EclipseReflectiveMembers.getClass(String fqn)",
                "CompilerMessageSuppressor.createWriterField(Writers w)",
                "Compiler.getCompiler(JavaFileManager jfm)",
                "Compiler.java9Compiler(JavaFileManager jfm)",
                "LombokProcessor.disablePartialReparseInNetBeansEditor(Context context)",
                "LombokProcessor.getJdkCompilerModule()",
                "LombokProcessor.addOpensForLombok()",
                "MarkingScanner.createAnnotation(Class<A> type, JCAnnotation anno, final JavacNode node)",
                "Delombok.shadowLoadClass(String name)",
                "UncheckedIOException.getMethod(Class<?> clazz, String name, String... paramTypes)",
                "EclipseLoaderPatcherTransplants.overrideLoadResult(ClassLoader original, String name, boolean resolve)",
                "Util.getShadowLoader()",
                "Util.shadowLoadClass(String name)",
                "AppleNativeLook.go()",
                "IdesList.openBrowser(final JHyperLink hyperlink, final URI location)",
                "VersionFinder.getVersion0(String mName)",
                "CommentCatcher.registerCommentsCollectingScannerFactory(Context context, boolean findTextBlocks)",
                "CommentCatcher.setInCompiler(JavaCompiler compiler, Context context)",
                "was.getMethod(Class<?> clazz, String name, String... paramTypes)",
                "EclipseInitializer.eclipseAvailable()",
                "CleanupTest.useThis()"
            ]
        }
    ]
}